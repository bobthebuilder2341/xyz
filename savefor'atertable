import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import PermanentDrawerLeftWorkflow from './PermanentDrawerLeftWorkflow';
import * as api from './api'; // Mock this file for API calls
import { SnackbarProvider } from 'notistack';
import { ThemeProvider, createTheme } from '@mui/material/styles';

jest.mock('./api', () => ({
  fetchProcessors: jest.fn(),
  fetchVersions: jest.fn(),
}));

const theme = createTheme();
const MockComponent = (props: any) => (
  <ThemeProvider theme={theme}>
    <SnackbarProvider>
      <PermanentDrawerLeftWorkflow {...props} />
    </SnackbarProvider>
  </ThemeProvider>
);

describe('PermanentDrawerLeftWorkflow', () => {
  const mockProps = {
    drawerFlag: true,
    nodeProperties: { displayName: 'Processor A', processorId: '123', versionId: 'v1' },
    nodeTypeOfSelectedNode: 'Document',
    handleNodeProperties: jest.fn(),
    handleDrawerFlag: jest.fn(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('should fetch processors list on mount when drawerFlag is true', async () => {
    (api.fetchProcessors as jest.Mock).mockResolvedValue({
      status: 'SUCCESS',
      response: [{ displayName: 'Processor A', processorId: '123' }],
    });

    render(<MockComponent {...mockProps} />);

    await waitFor(() => {
      expect(api.fetchProcessors).toHaveBeenCalled();
    });

    expect(screen.getByDisplayValue('Processor A')).toBeInTheDocument();
  });

  test('should set processorId when processorName changes', async () => {
    (api.fetchProcessors as jest.Mock).mockResolvedValue({
      status: 'SUCCESS',
      response: [{ displayName: 'Processor B', processorId: '456' }],
    });

    render(<MockComponent {...mockProps} />);

    await waitFor(() => {
      expect(api.fetchProcessors).toHaveBeenCalled();
    });

    fireEvent.change(screen.getByLabelText('Processor Name'), { target: { value: 'Processor B' } });
    await waitFor(() => {
      expect(screen.getByDisplayValue('Processor B')).toBeInTheDocument();
    });
  });

  test('should fetch versions list when processorId changes', async () => {
    (api.fetchProcessors as jest.Mock).mockResolvedValue({
      status: 'SUCCESS',
      response: [{ displayName: 'Processor A', processorId: '123' }],
    });
    (api.fetchVersions as jest.Mock).mockResolvedValue({
      status: 'SUCCESS',
      response: [{ versionId: 'v2' }],
    });

    render(<MockComponent {...mockProps} />);

    await waitFor(() => {
      expect(api.fetchProcessors).toHaveBeenCalled();
    });

    fireEvent.change(screen.getByLabelText('Processor Name'), { target: { value: 'Processor A' } });
    await waitFor(() => {
      expect(api.fetchVersions).toHaveBeenCalledWith('123');
    });
  });

  test('should show error message on API failure', async () => {
    (api.fetchProcessors as jest.Mock).mockRejectedValue({ detail: 'Error fetching processors' });

    render(<MockComponent {...mockProps} />);

    await waitFor(() => {
      expect(api.fetchProcessors).toHaveBeenCalled();
    });

    expect(screen.getByText('Error fetching processors')).toBeInTheDocument();
  });

  test('should update node properties on save button click', () => {
    render(<MockComponent {...mockProps} />);

    fireEvent.click(screen.getByText('Save'));

    expect(mockProps.handleNodeProperties).toHaveBeenCalledWith({
      processorId: '123',
      displayName: 'Processor A',
      type: 'Doc AI',
      versionId: 'v1',
      category: 'Document',
    });
  });

  test('should reset states and close drawer on handleClick', () => {
    render(<MockComponent {...mockProps} />);

    fireEvent.click(screen.getByText('Close'));

    expect(mockProps.handleDrawerFlag).toHaveBeenCalledWith(false);
    expect(screen.queryByDisplayValue('Processor A')).not.toBeInTheDocument();
  });

  test('should handle error and close error message on close', () => {
    (api.fetchProcessors as jest.Mock).mockRejectedValue({ detail: 'Error fetching processors' });

    render(<MockComponent {...mockProps} />);

    waitFor(() => {
      expect(screen.getByText('Error fetching processors')).toBeInTheDocument();
    });

    fireEvent.click(screen.getByLabelText('Close Error'));

    expect(screen.queryByText('Error fetching processors')).not.toBeInTheDocument();
  });
});
